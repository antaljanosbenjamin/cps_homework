%sudo apt install libboost-all-dev
%sudo apt install libcurlpp-dev
%sudo apt install libcurl4-openssl-dev
%sudo apt install libssl-dev
%sudo apt install uuid-dev
%https://github.com/beniz/deepdetect/issues/126
%https://github.com/Azure/azure-iot-sdk-c/blob/master/doc/devbox_setup.md
%https://github.com/Azure/azure-iot-sdk-c/blob/master/doc/ubuntu_apt-get_sample_setup.md
%https://www.rti.com/gettingstarted/installlinux_secure
%https://unix.stackexchange.com/questions/389156/how-to-fix-held-broken-packages/389170

\LoadClass[a4paper]{article}
\documentclass{article}

\usepackage{listings}
\lstset{
basicstyle=\ttfamily,
columns=flexible,
breaklines=true
}
\usepackage{color}

\definecolor{mygray}{rgb}{0.4,0.4,0.4}
\definecolor{mygreen}{rgb}{0,0.0,0.6}
\definecolor{myorange}{rgb}{1.0,0.4,0}

\lstset{
commentstyle=\color{mygray},
frame=none,
numbersep=5pt,
numberstyle=\tiny\color{mygray},
keywordstyle=\color{mygreen},
showspaces=false,
showstringspaces=false,
stringstyle=\color{myorange},
tabsize=2
}

\usepackage{verbatim}

\usepackage[hidelinks]{hyperref}
\hypersetup{
	colorlinks=true,
    pdfborder={0 0 0},
    urlcolor     = blue, %Colour for external hyperlinks
    linkcolor    = blue, %Colour of internal links
    citecolor   = red %Colour of citations
}

\usepackage{titlesec}
\newcommand{\sectionbreak}{\clearpage}

\usepackage{graphicx}

\author{Janos Benjamin Antal\\\href{mailto:antal.janos.benjamin@gmail.com}{antal.janos.benjamin@gmail.com}}
\title{CPS Humidity Homework}
\begin{document}
\maketitle
\section{Prerequisites}

To build the application on Linux Mint 18.3 the following steps are needed:

\begin{itemize}
\item Install required packages with apt: 
\begin{itemize}
\item \verb+libboost-all-dev+
\item \verb+libcurl4-openssl-dev+
\item \verb+libssl-dev+ %(some help can be found \href{https://unix.stackexchange.com/a/389170}{here})
\item \verb+uuid-dev+
\item \verb+rapidjson-dev+
\item \verb+build-essential+
\item \verb+cmake+
\item \verb!g++!
\item \verb+git+
\end{itemize}
Use the following command:
\begin{lstlisting}
$ sudo apt install libboost-all-dev libcurl4-openssl-dev libssl-dev uuid-dev rapidjson-dev build-essential cmake g++ git
\end{lstlisting}
\item Install \href{http://www.curlpp.org/}{cURLpp} with the steps described \href{https://github.com/beniz/deepdetect/issues/126}{here}:
\begin{verbatim}
$ sudo apt-get remove libcurlpp0
$ mkdir curlppbuild
$ cd curlppbuild
$ git clone https://github.com/jpbarrette/curlpp.git
$ cd curlpp
$ cmake .
$ sudo make install
\end{verbatim} 
\item Install AzureIoT C SDKfrom \href{https://github.com/Azure/azure-iot-sdk-c/blob/master/doc/devbox_setup.md}{source}. After building the SDK use \verb+sudo make install+ to copy the header and the lib files to the system include path.
\item Download and install \href{https://www.rti.com/gettingstarted/installlinux_secure}{RTI Connext DDS 5.3}
\item Set the \verb+NDDSHOME+ environment variable to the root of RTI Connext DDS, e.g.: \verb+/opt/rti_connext_dds-5.3.0+
\end{itemize}

\section{Build}
\begin{enumerate}
\item Clone git repository
\begin{lstlisting}
$ git clone https://github.com/antaljanosbenjamin/cps_homework.git
\end{lstlisting}
\item Generate source code from .idl files
\begin{lstlisting}[language=bash]
$ cd cps_homework
$ $NDDSHOME/bin/rtiddsgen  -language C++11 -stl -d DDS/Config/common -replace idl_files/Config.idl
$ $NDDSHOME/bin/rtiddsgen  -language C++11 -stl -d DDS/Decision/common -replace idl_files/Decision.idl
$ $NDDSHOME/bin/rtiddsgen  -language C++11 -stl -d DDS/Schedule/common -replace idl_files/Schedule.idl
$ $NDDSHOME/bin/rtiddsgen  -language C++11 -stl -d DDS/Humidity/common -replace idl_files/UvegHaz.idl
$ $NDDSHOME/bin/rtiddsgen  -language C++11 -stl -d DDS/Weather/common -replace idl_files/Weather.idl
\end{lstlisting}
\item Build
\begin{lstlisting}
$ mkdir build
$ cd build
$ cmake ..
$ make [-j 8]
\end{lstlisting}
\end{enumerate}

\section{Run demo}
\begin{enumerate}
\item Start humidity publisher
\begin{verbatim}
$ ./cps_main h <humidityDataFilePath>
\end{verbatim}

As result of this command the application will read the data file and start to publish a humidity value every 4 minutes. The file shall contains a humidity value per line. Each humidity value is a decimal number. See example \href{https://github.com/antaljanosbenjamin/cps_homework/blob/master/examples/humidity.txt}{file}.
\item Start IoTEdge 
\begin{lstlisting}
$ ./cps_main e <weatherApiKey> <azureConnectionString> <scheduleFilePath>
\end{lstlisting} 
The meaning of parameteres are the following:
\begin{itemize}
\item \verb+weatherApiKey+: an API key for http://api.airvisual.com
\item \verb+azureConnectionString+: the connection string of the device used Azure IoT Hub
\item \verb+scheduleFilePath+: path to a CSV file which stores the schedules time intervals. See example \href{https://github.com/antaljanosbenjamin/cps_homework/blob/master/examples/schedule.csv}{file}.
\end{itemize}

The IoTEdge module is responsible for comunication with Azure IoT Hub, the weather information system and also to send schedule information through DDS topic.
\item Start humidity controller
\begin{verbatim}
$ ./cps_main c
\end{verbatim}

The controller receives the required informations and sensor values and also make decisions based on the collected data. It also sends the decision input and output to the IoTEdge in order to store them in the cloud.
\end{enumerate}
\section{System architecture}
The system consists three modules:
\begin{itemize}
\item IoTEdge
\item Controller
\item Publisher
\end{itemize}
The publisher module exists only for testing purposes, so this documentation doesn't contains it's details.
\subsection{IoTEdge}
\begin{figure}[!htb]
  \includegraphics[width=\linewidth]{imgs/edge.png}
  \caption{Architecture of IoT Edge}
  \label{fig:arc_edge}
\end{figure}

As the figure \ref{fig:arc_edge} shows, the IoTEdge translates the messages received from the cloud and the weather forecast API to DDS messages and vica versa. The DDS Interface Description Language exactly describe the contents of the used DDS messages:
\begin{verbatim}
struct Config {
    double maxTemperature;
    unsigned long maxPollution;
    unsigned long minHumidity;
    unsigned long maxHumidity;
};

struct Schedule {
    boolean scheduled;
    unsigned long until;
    unsigned long sentTS;
};

struct UvegHaz{
    string ID; //@key
    double Value;
    long TimeStamp;
};

struct Weather {
    double  temperature;
    unsigned long tempTS;
    unsigned long pollution;
    unsigned long pollTS;
};

enum Decision { CLOSE, OPEN };

struct DecisionInfo {
    unsigned long decisionTS;
    Decision decision;
    Config config;
    Weather lastWeather;
    Schedule lastSchedule;
    UvegHaz lastHumidity;
};
\end{verbatim}

The most complex part of the IoTEdge module is the IoTHub Client. It is responsible for translating and communicating between the IoTEdge and AzureIoT Hub. It sends the received sensor, weather and decision data to the cloud, and also receives config message from it. A config message contains the maximum outside temperature, the maximum outside pollution and the desired minimum and maximum temperature in the classroom. For example:
\begin{verbatim}
{
    "maximumTemperature" : 50,
    "maximumPollution" : 55,
    "minimumHumidity" : 42,
    "maximumHumidity" : 46
}
\end{verbatim}
\begin{itemize}
\item maximumTemperature: a temperature value in Celsius. If the outside temperature reaches this limit, the controller logic mustn't decide to open the window.
\item maximumPollution:  a pollution value in Air Quality Index. If the outside pollution reaches this limit, the controller logic mustn't decide to open the window.
\item minimumHumidity, maximumHumidity: the desired range of humidity expressed as relative humidity. The goal of the system it to keep humidity within this range.
\end{itemize}
\subsubsection{IoTHub Client}

The IoTHub Client is a reusable part of the implementation. It's public interface are really simple:

\begin{lstlisting}[language=C++]{Name=test2}
class IoTHubClient final {
public:

    IoTHubClient(const std::string &connectionString,
                 std::function<void(const rapidjson::Document &)> receivedMessageConsumer, 
                 bool trace = false,
                 uint32_t keepAlive = 240);

    ~IoTHubClient();

    void start();

    void stop();

    void sendMessage(const rapidjson::Document &message);
};
\end{lstlisting}

The implementation is based on an official Azure IoT C SDK \href{https://github.com/Azure/azure-iot-sdk-c/blob/master/iothub_client/samples/iothub_client_sample_amqp/iothub_client_sample_amqp.c}{example}. Usage of the module also really simple. The constructor takes an Azure IoT Hub decive connection string, a message consumer function and two other parameters. More information about the last two parameters can be found in the referenced example. To start receiving/sending messages with an existing instance of IoTHubClient, the \verb+start()+ function has to be called. After the calling, the instance starts to receive messages from IoT Hub and also sends messages to it when \verb+sendMessage(msg)+ is called.

\subsubsection{Abstract DDS classes}

All of the \verb+XXXPublisher+ and the \verb+XXXSubscriber+ in this project is derived from \verb+AbstractPublisher+ and \verb+AbstractSubscriber+. They are generic template classes in order to make easy to create DDS publishers and subscribers. The interface of \verb+AbstractPublisher+ is the following:
\begin{lstlisting}[language=C++]{Name=test2}
template<typename DataT>
class AbstractPublisher {
public:
    AbstractPublisher(int domain_id,
                      const std::string &topic_name);

    virtual ~AbstractPublisher();

    void publishData(const DataT &data);
};
\end{lstlisting}
The \verb+DataT+ template parameter should be DDS generated message's type. The \verb+publishData(data)+ function can be used to send a message to the given topic.

The \verb+AbstractSubscriber+'s interface is very similar:
\begin{lstlisting}[language=C++]{Name=test2}
template<typename DataT>
class AbstractSubscriber : public dds::sub::NoOpDataReaderListener<DataT> {
public:

    AbstractSubscriber(int domain_id, 
                       const std::string &topic_name, 
                       int pollSeconds);

    virtual ~AbstractSubscriber();

    void on_data_available(dds::sub::DataReader<DataT> &reader) override ;

    void startReceiving(std::function<void(const DataT &data)> consumerFunction);

    void stopReceiving();
};
\end{lstlisting}

The \verb+on_data_available(dds::sub::DataReader<DataT> &reader)+ inherited from the base class, and shouldn't be called by the user. To start receiving messages the \verb+startReceiving(consumerFunction)+ function has to be called. After that, the subscriber will call the \verb+consumberFunction+ when a new message arrives.
\subsection{Controller}
The Controller receives the DDS messages with the required informations (scheduling, weather information, measured sensor values and configuration messsages), and makes decision based on them. Figure \ref{fig:decision_logic} shows the exact process of decision making. Decision making runs periodically in each 5 minutes, and decision is also made on receiving every input messages. It's important to make decision independently to message receiving, because the last known informations can be outdated. In case of any information is outdated, the decision output must be \verb+CLOSED+ in order to avoid opened window under not safe circumstances.
\begin{figure}[!htb]
  \includegraphics[width=250px]{imgs/decision_logic.png}
  \caption{Flow diagram of decision logic}
  \label{fig:decision_logic}
\end{figure} 
\end{document}
